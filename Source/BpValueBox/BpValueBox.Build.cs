// Copyright Epic Games, Inc. All Rights Reserved.

using System.Collections.Generic;
using System.Text;
using System.IO;
using EpicGames.Core;
using UnrealBuildTool;

public class BpValueBox : ModuleRules
{
	public BpValueBox(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicIncludePaths.AddRange(
			new string[]
			{
				// ... add public include paths required here ...
			}
		);


		PrivateIncludePaths.AddRange(
			new string[]
			{
				// ... add other private include paths required here ...
			}
		);


		PublicDependencyModuleNames.AddRange(
			new[]
			{
				"Core"
				// ... add other public dependencies that you statically link with here ...
			}
		);


		PrivateDependencyModuleNames.AddRange(
			new[]
			{
				"CoreUObject",
				"Engine",
				"Slate",
				"SlateCore"
				// ... add private dependencies that you statically link with here ...	
			}
		);


		DynamicallyLoadedModuleNames.AddRange(
			new string[]
			{
				// ... add any modules that your module loads dynamically here ...
			}
		);
		GenerateBoxedValueTypes();
	}

	private void GenerateBoxedValueTypes()
	{
		string publicDir = Path.Combine(ModuleDirectory, "Public");
		Directory.CreateDirectory(publicDir);
		string outPath = Path.Combine(publicDir, "BoxedValue_Generated.h");
		
		/* Reference:
		UCLASS(Blueprintable)
		class BPVALUEBOX_API UBoxedStruct : public UObject, public IBoxedType
		{
		GENERATED_BODY()

		public:
		UPROPERTY(BlueprintReadWrite)
		FInstancedStruct Value = FInstancedStruct();

		virtual EValueType GetType_Implementation() override { return EValueType::Struct; }

		UFUNCTION(BlueprintCallable, meta = ( DefaultToSelf = Context ), Category=""BoxedValue"")
		static UBoxedStruct* BoxStruct(UObject* Context, const FInstancedStruct& Input)
		{
		    return UBoxedValueStatics::BoxValue<UBoxedStruct>(Context, Input);
		}

		UFUNCTION(BlueprintPure, Category=""BoxedValue"")
		static FInstancedStruct AsStruct(const TScriptInterface<IBoxedType>& Input)
		{
		    return UBoxedValueStatics::GetValue<FInstancedStruct, UBoxedStruct>(Input);
		}
		*/

		List<(string type, string name)> types = new()
		{
			("FInstancedStruct", "Struct"),
			("bool", "Bool"),
			("uint8", "Byte"),
			("int32", "Int32"),
			("int64", "Int64"),
			("float", "Float32"),
			("double", "Float64"),
			("FName", "Name"),
			("FString", "String"),
			("FText", "Text"),
			("FVector", "Vector"),
			("FRotator", "Rotator"),
			// Are any of these necessary?
			// ("FTransform", "Transform"),
			// ("FLinearColor", "LinearColor"),
			// ("FColor", "Color"),
			// ("FGuid", "Guid"),
			// ("FQuat", "Quat"),
			// ("FVector2D", "Vector2D"),
			// ("FDateTime", "DateTime"),
			// ("FTimespan", "Timespan"),
			// ("FSoftObjectPath", "SoftObjectPath"),
			// ("FSoftClassPath", "SoftClassPath"),
			// ("FSoftPackagePath", "SoftPackagePath"),
			// ("FSoftAssetPath", "SoftAssetPath"),
		};

		StringBuilder sb = new();
		sb.AppendLine(@"
// This file is automatically generated by BpValueBox.Build.cs. It will be overwritten during builds.
// If you need to customize generation, modify BpValueBox.Build.cs instead.

#pragma once

#include ""StructUtils/InstancedStruct.h""
#include ""BoxedValue.h""
#include ""BoxedValue_Generated.generated.h""
");

		foreach (var type in types)
		{
			sb.AppendLine($@"
UCLASS(Blueprintable)
class BPVALUEBOX_API UBoxed{type.name} : public UObject, public IBoxedType
{{
	GENERATED_BODY()

public:
	UPROPERTY(BlueprintReadWrite)
	{type.type} Value = {type.type}{{}};

	virtual EValueType GetType_Implementation() override {{ return EValueType::{type.name}; }}

	UFUNCTION(BlueprintCallable, meta = ( DefaultToSelf = Context ), Category=""BoxedValue"")
	static UBoxed{type.name}* Box{type.name}(UObject* Context, const {type.type}& Input)
	{{
		return UBoxedValueStatics::BoxValue<UBoxed{type.name}>(Context, Input);
	}}

	UFUNCTION(BlueprintPure, Category=""BoxedValue"")
	static {type.type} As{type.name}(const TScriptInterface<IBoxedType>& Input)
	{{
		return UBoxedValueStatics::GetValue<{type.type}, UBoxed{type.name}>(Input);
	}}
}};
");
		}
		
		string newContents = sb.ToString();
		bool needWrite = true;
		if (File.Exists(outPath))
		{
			string existing = File.ReadAllText(outPath);
			needWrite = existing != newContents;
		}

		if (needWrite)
		{
			File.WriteAllText(outPath, newContents, Encoding.UTF8);
		}
	}
}